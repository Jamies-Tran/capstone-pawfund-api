package com.paw.fund.app.module.account.service;
// Generated by Qodo Gen

import com.paw.fund.app.modules.account_management.domain.Account;
import com.paw.fund.app.modules.account_management.domain.IAccountMapper;
import com.paw.fund.app.modules.account_management.repository.database.AccountEntity;
import com.paw.fund.app.modules.account_management.repository.database.IAccountRepository;
import com.paw.fund.app.modules.account_management.service.AccountCommandService;

import com.paw.fund.app.modules.auditable_management.repository.database.AuditableEntity;
import com.paw.fund.app.modules.auditable_management.service.AuditableUseCaseService;
import com.paw.fund.app.modules.auditable_management.service.usecase.IAuditableUseCase;
import com.paw.fund.configuration.handler.exceptions.ResourceDuplicateException;
import com.paw.fund.configuration.handler.exceptions.ResourceNotFoundException;
import com.paw.fund.configuration.request.context.RequestContext;
import com.paw.fund.enums.EAccountStatus;
import com.paw.fund.utils.password.encoder.PawFundPasswordEncoder;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.jdbc.EmbeddedDatabaseConnection;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import java.util.Optional;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.NONE)
public class AccountCommandServiceTest {
    @Mock
    IAccountRepository repository;

    @Mock
    RequestContext requestContext;

    @Mock
    AuditableUseCaseService auditableUseCase;

    @Mock
    IAccountMapper mapper;

    @Mock
    BCryptPasswordEncoder bCryptPasswordEncoder;

    @Mock
    PawFundPasswordEncoder passwordEncoder;

    @InjectMocks
    AccountCommandService accountCommandService;

    // Successfully save a new account with valid data
    @Test
    public void test_save_account_with_valid_data() {
        // Arrange
        Account account = Account.builder()
            .firstName("John")
            .lastName("Doe")
            .email("john.doe@example.com")
            .phone("0123456789")
            .identification("123456789012")
            .build();
    
        AccountEntity accountEntity = new AccountEntity();
        AccountEntity savedAccountEntity = new AccountEntity();
        savedAccountEntity.setAccountId(1L);
    
        AuditableEntity auditableEntity = new AuditableEntity();
    
        when(repository.existsByEmail(anyString())).thenReturn(false);
        when(repository.existsByPhone(anyString())).thenReturn(false);
        when(repository.existsByIdentification(anyString())).thenReturn(false);
        when(mapper.toEntity(any(Account.class))).thenReturn(accountEntity);
        when(auditableUseCase.createAuditableForNew()).thenReturn(auditableEntity);
        when(repository.save(any(AccountEntity.class))).thenReturn(savedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(account.withAccountId(1L));
    
        // Act
        Account result = accountCommandService.save(account);
    
        // Assert
        assertNotNull(result);
        assertEquals(Long.valueOf(1), result.accountId());
        verify(repository).existsByEmail("john.doe@example.com");
        verify(repository).existsByPhone("0123456789");
        verify(repository).existsByIdentification("123456789012");
        verify(mapper).toEntity(account);
        verify(auditableUseCase).createAuditableForNew();
        verify(repository).save(accountEntity);
        verify(mapper).toDto(savedAccountEntity);
    }

    // Throw NullPointerException when saving null account
    @Test
    public void test_save_null_account_throws_exception() {
        // Arrange
        Account account = null;
    
        // Act & Assert
        assertThrows(NullPointerException.class, () -> {
            accountCommandService.save(account);
        });
    
        // Verify no interactions with dependencies
        verifyNoInteractions(repository);
        verifyNoInteractions(auditableUseCase);
        verifyNoInteractions(mapper);
        verifyNoInteractions(passwordEncoder);
    }

    // Successfully update an account's email with valid accountId and email
    @Test
    public void test_update_email_with_valid_account_id_and_email() {
        // Arrange
        Long accountId = 1L;
        String newEmail = "new.email@example.com";
        AccountEntity accountEntity = new AccountEntity();
        accountEntity.setAccountId(accountId);
        accountEntity.setEmail("old.email@example.com");
    
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setAccountId(accountId);
        updatedAccountEntity.setEmail(newEmail);
    
        when(repository.findById(accountId)).thenReturn(Optional.of(accountEntity));
        when(repository.save(any(AccountEntity.class))).thenReturn(updatedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(Account.builder().accountId(accountId).email(newEmail).build());
        when(auditableUseCase.createAuditableForUpdate()).thenReturn(new AuditableEntity());
    
        // Act
        Account result = accountCommandService.updateEmail(accountId, newEmail);
    
        // Assert
        assertNotNull(result);
        assertEquals(accountId, result.accountId());
        assertEquals(newEmail, result.email());
        verify(repository).findById(accountId);
        verify(repository).save(accountEntity);
        verify(mapper).toDto(updatedAccountEntity);
    }

    // Successfully update an account's status with valid accountId and status
    @Test
    public void test_update_status_with_valid_account_id_and_status() {
        // Arrange
        Long accountId = 1L;
        EAccountStatus newStatus = EAccountStatus.ACTIVE;
        AccountEntity accountEntity = new AccountEntity();
        accountEntity.setAccountId(accountId);
        accountEntity.setStatusCode(EAccountStatus.INACTIVE.getCode());
        accountEntity.setStatusName(EAccountStatus.INACTIVE.getName());
    
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setAccountId(accountId);
        updatedAccountEntity.setStatusCode(newStatus.getCode());
        updatedAccountEntity.setStatusName(newStatus.getName());
    
        AuditableEntity auditableEntity = new AuditableEntity();
    
        when(repository.findById(accountId)).thenReturn(Optional.of(accountEntity));
        when(auditableUseCase.createAuditableForUpdate()).thenReturn(auditableEntity);
        when(repository.save(any(AccountEntity.class))).thenReturn(updatedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(new Account(accountId, null, null, null, null, null, null, null, null, null, null, null, null, newStatus.getCode(), newStatus.getName()));
    
        // Act
        Account result = accountCommandService.updateStatus(accountId, newStatus);
    
        // Assert
        assertNotNull(result);
        assertEquals(newStatus.getCode(), result.statusCode());
        assertEquals(newStatus.getName(), result.statusName());
        verify(repository).findById(accountId);
        verify(auditableUseCase).createAuditableForUpdate();
        verify(repository).save(accountEntity);
        verify(mapper).toDto(updatedAccountEntity);
    }

    // Successfully delete an account with valid accountId
    @Test
    public void test_delete_account_with_valid_account_id() {
        // Arrange
        Long accountId = 1L;
        AccountEntity accountEntity = new AccountEntity();
        accountEntity.setAccountId(accountId);
    
        when(repository.findById(accountId)).thenReturn(Optional.of(accountEntity));
        doNothing().when(repository).delete(accountEntity);
    
        // Act
        accountCommandService.delete(accountId);
    
        // Assert
        verify(repository).findById(accountId);
        verify(repository).delete(accountEntity);
    }

    // Successfully update an account with valid accountId and account data
    @Test
    public void test_update_account_with_valid_data() {
        // Arrange
        Long accountId = 1L;
        Account account = Account.builder()
            .firstName("Jane")
            .lastName("Doe")
            .email("jane.doe@example.com")
            .phone("0987654321")
            .identification("987654321098")
            .build();
    
        AccountEntity foundAccountEntity = new AccountEntity();
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setAccountId(accountId);
    
        AuditableEntity auditableEntity = new AuditableEntity();
    
        when(repository.findById(accountId)).thenReturn(Optional.of(foundAccountEntity));
        when(repository.existsByEmail(anyString())).thenReturn(false);
        when(repository.existsByPhone(anyString())).thenReturn(false);
        when(repository.existsByIdentification(anyString())).thenReturn(false);
        when(auditableUseCase.createAuditableForUpdate()).thenReturn(auditableEntity);
        when(repository.save(any(AccountEntity.class))).thenReturn(updatedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(account.withAccountId(accountId));
    
        // Act
        Account result = accountCommandService.update(accountId, account);
    
        // Assert
        assertNotNull(result);
        assertEquals(accountId, result.accountId());
        verify(repository).findById(accountId);
        verify(mapper).update(foundAccountEntity, account);
        verify(auditableUseCase).createAuditableForUpdate();
        verify(repository).save(foundAccountEntity);
        verify(mapper).toDto(updatedAccountEntity);
    }

    // Successfully update an account's password with valid accountId and password
    @Test
    public void test_update_password_with_valid_account_id_and_password() {
        // Arrange
        Long accountId = 1L;
        String newPassword = "newSecurePassword";
        AccountEntity foundAccountEntity = new AccountEntity();
        foundAccountEntity.setAccountId(accountId);
        foundAccountEntity.setPassword("oldPasswordHash");
    
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setAccountId(accountId);
        updatedAccountEntity.setPassword("newPasswordHash");
    
        Account expectedAccount = Account.builder()
            .accountId(accountId)
            .password("newPasswordHash")
            .build();
    
        when(repository.findById(accountId)).thenReturn(Optional.of(foundAccountEntity));
        when(passwordEncoder.bCryptpasswordEncoder()).thenReturn(bCryptPasswordEncoder);
        when(passwordEncoder.bCryptpasswordEncoder().encode(newPassword)).thenReturn("newPasswordHash");
        when(repository.save(foundAccountEntity)).thenReturn(updatedAccountEntity);
        when(mapper.toDto(updatedAccountEntity)).thenReturn(expectedAccount);
    
        // Act
        Account result = accountCommandService.updatePassword(accountId, newPassword);
    
        // Assert
        assertNotNull(result);
        assertEquals("newPasswordHash", result.password());
        verify(repository).findById(accountId);
        verify(passwordEncoder.bCryptpasswordEncoder()).encode(newPassword);
        verify(repository).save(foundAccountEntity);
        verify(mapper).toDto(updatedAccountEntity);
    }

    // Throw ResourceDuplicateException when saving account with existing email
    @Test
    public void test_save_account_with_existing_email_throws_exception() {
        // Arrange
        Account account = Account.builder()
            .firstName("Jane")
            .lastName("Doe")
            .email("jane.doe@example.com")
            .phone("0987654321")
            .identification("987654321098")
            .build();

        when(repository.existsByEmail("jane.doe@example.com")).thenReturn(true);

        // Act & Assert
        assertThrows(ResourceDuplicateException.class, () -> {
            accountCommandService.save(account);
        });

        verify(repository).existsByEmail("jane.doe@example.com");
        verify(repository, times(1)).existsByPhone(anyString());
        verify(repository, times(1)).existsByIdentification(anyString());
        verify(mapper, never()).toEntity(any(Account.class));
        verify(auditableUseCase, never()).createAuditableForNew();
        verify(repository, never()).save(any(AccountEntity.class));
        verify(mapper, never()).toDto(any(AccountEntity.class));
    }

    // Throw ResourceDuplicateException when saving account with existing phone
    @Test
    public void test_save_account_with_existing_phone_throws_exception() {
        // Arrange
        Account account = Account.builder()
            .firstName("Jane")
            .lastName("Doe")
            .email("jane.doe@example.com")
            .phone("0987654321")
            .identification("987654321098")
            .build();

        when(repository.existsByEmail(anyString())).thenReturn(false);
        when(repository.existsByPhone("0987654321")).thenReturn(true);
        when(repository.existsByIdentification(anyString())).thenReturn(false);

        // Act & Assert
        assertThrows(ResourceDuplicateException.class, () -> {
            accountCommandService.save(account);
        });

        verify(repository).existsByEmail("jane.doe@example.com");
        verify(repository).existsByPhone("0987654321");
        verify(repository).existsByIdentification("987654321098");
    }

    // Throw IllegalArgumentException when updating status with null accountId or status
    @Test
    public void test_update_status_with_null_arguments_throws_exception() {
        // Arrange
        Long nullAccountId = null;
        EAccountStatus nullStatus = null;

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            accountCommandService.updateStatus(nullAccountId, EAccountStatus.ACTIVE);
        });

        assertThrows(IllegalArgumentException.class, () -> {
            accountCommandService.updateStatus(1L, nullStatus);
        });
    }

    // Throw ResourceDuplicateException when saving account with existing identification
    @Test
    public void test_save_account_with_existing_identification_throws_exception() {
        // Arrange
        Account account = Account.builder()
            .firstName("Jane")
            .lastName("Doe")
            .email("jane.doe@example.com")
            .phone("0987654321")
            .identification("987654321098")
            .build();

        when(repository.existsByEmail(anyString())).thenReturn(false);
        when(repository.existsByPhone(anyString())).thenReturn(false);
        when(repository.existsByIdentification("987654321098")).thenReturn(true);

        // Act & Assert
        assertThrows(ResourceDuplicateException.class, () -> {
            accountCommandService.save(account);
        });

        verify(repository).existsByEmail("jane.doe@example.com");
        verify(repository).existsByPhone("0987654321");
        verify(repository).existsByIdentification("987654321098");
    }

    // Throw ResourceNotFoundException when updating status for non-existent account
    @Test
    public void test_update_status_non_existent_account_throws_exception() {
        // Arrange
        Long nonExistentAccountId = 999L;
        EAccountStatus newStatus = EAccountStatus.ACTIVE;

        when(repository.findById(nonExistentAccountId)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(ResourceNotFoundException.class, () -> {
            accountCommandService.updateStatus(nonExistentAccountId, newStatus);
        });

        verify(repository).findById(nonExistentAccountId);
    }

    // Throw ResourceNotFoundException when updating email for non-existent account
    @Test
    public void test_update_email_non_existent_account_throws_exception() {
        // Arrange
        Long nonExistentAccountId = 999L;
        String newEmail = "new.email@example.com";

        when(repository.findById(nonExistentAccountId)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(ResourceNotFoundException.class, () -> {
            accountCommandService.updateEmail(nonExistentAccountId, newEmail);
        });

        verify(repository).findById(nonExistentAccountId);
        verifyNoMoreInteractions(repository, mapper, auditableUseCase);
    }

    // Throw ResourceDuplicateException when updating account with email that exists for another account
    @Test
    public void test_update_account_with_existing_email_throws_exception() {
        // Arrange
        Long accountId = 1L;
        Account existingAccount = Account.builder()
            .accountId(accountId)
            .email("existing.email@example.com")
            .build();
    
        Account updateAccount = Account.builder()
            .accountId(accountId)
            .email("new.email@example.com")
            .build();
    
        AccountEntity foundAccountEntity = new AccountEntity();
        foundAccountEntity.setEmail("existing.email@example.com");
    
        when(repository.findById(accountId)).thenReturn(Optional.of(foundAccountEntity));
        when(repository.existsByEmail("new.email@example.com")).thenReturn(true);
    
        // Act & Assert
        assertThrows(ResourceDuplicateException.class, () -> {
            accountCommandService.update(accountId, updateAccount);
        });
    
        verify(repository).findById(accountId);
        verify(repository).existsByEmail("new.email@example.com");
    }

    // Check that validateDelete method always returns true (current implementation)
    @Test
    public void test_validate_delete_always_returns_true() {
        // Arrange
        Long accountId = 1L;
        AccountCommandService accountCommandService = new AccountCommandService(
            mock(IAccountRepository.class),
            mock(IAuditableUseCase.class),
            mock(IAccountMapper.class),
            mock(PawFundPasswordEncoder.class)
        );

        // Act
        boolean result = accountCommandService.validateDelete(accountId);

        // Assert
        assertTrue(result);
    }

    // Validate that password is properly encoded when saving or updating password
    @Test
    public void test_update_password_encodes_password() {
        // Arrange
        Long accountId = 1L;
        String rawPassword = "plainPassword";
        String encodedPassword = "encodedPassword";
    
        AccountEntity foundAccount = new AccountEntity();
        foundAccount.setAccountId(accountId);
    
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setAccountId(accountId);
        updatedAccountEntity.setPassword(encodedPassword);
    
        when(repository.findById(accountId)).thenReturn(Optional.of(foundAccount));
        when(passwordEncoder.bCryptpasswordEncoder()).thenReturn(bCryptPasswordEncoder);
        when(passwordEncoder.bCryptpasswordEncoder().encode(rawPassword)).thenReturn(encodedPassword);
        when(repository.save(any(AccountEntity.class))).thenReturn(updatedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(new Account(accountId, null, null, null, null, encodedPassword, null, null, null, null, null, null, null, null, null));
    
        // Act
        Account result = accountCommandService.updatePassword(accountId, rawPassword);
    
        // Assert
        assertNotNull(result);
        assertEquals(encodedPassword, result.password());
        verify(repository).findById(accountId);
        verify(passwordEncoder.bCryptpasswordEncoder()).encode(rawPassword);
        verify(repository).save(foundAccount);
        verify(mapper).toDto(updatedAccountEntity);
    }

    // Verify auditable fields are properly set during save and update operations
    @Test
    public void test_auditable_fields_set_on_save_and_update() {
        // Arrange
        Account account = Account.builder()
            .firstName("Jane")
            .lastName("Doe")
            .email("jane.doe@example.com")
            .phone("0987654321")
            .identification("987654321098")
            .build();

        AccountEntity accountEntity = AccountEntity.builder()
                .accountId(1L)
                .firstName("John")
                .lastName("Doe")
                .email("john.doe@example.com")
                .phone("0123456789")
                .identification("123456789012")
                .build();
        AccountEntity savedAccountEntity = new AccountEntity();
        savedAccountEntity.setAccountId(1L);
        savedAccountEntity.setFirstName("John");
        savedAccountEntity.setLastName("Doe");
        savedAccountEntity.setEmail("john.doe@example.com");
        savedAccountEntity.setPhone("0123456789");
        savedAccountEntity.setIdentification("1234567890");

        AuditableEntity auditableForNew = new AuditableEntity();
        AuditableEntity auditableForUpdate = new AuditableEntity();

        when(repository.findById(any())).thenReturn(Optional.of(accountEntity));
        when(repository.existsByEmail(anyString())).thenReturn(false);
        when(repository.existsByPhone(anyString())).thenReturn(false);
        when(repository.existsByIdentification(anyString())).thenReturn(false);
        when(mapper.toEntity(any(Account.class))).thenReturn(accountEntity);
        when(auditableUseCase.createAuditableForNew()).thenReturn(auditableForNew);
        when(auditableUseCase.createAuditableForUpdate()).thenReturn(auditableForUpdate);
        when(repository.save(any(AccountEntity.class))).thenReturn(savedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(account.withAccountId(1L));

        // Act
        Account savedAccount = accountCommandService.save(account);
        Account updatedAccount = accountCommandService.update(savedAccount.accountId(), account);

        // Assert
        assertNotNull(savedAccount);
        assertEquals(Long.valueOf(1L), savedAccount.accountId());
        assertNotNull(updatedAccount);
        assertEquals(Long.valueOf(1L), updatedAccount.accountId());

        verify(mapper).toEntity(account);
        verify(auditableUseCase).createAuditableForNew();
        verify(auditableUseCase).createAuditableForUpdate();
        verify(repository, times(2)).save(accountEntity);
        verify(mapper, times(2)).toDto(savedAccountEntity);
    }

    // Verify mapper correctly converts between Entity and DTO objects
    @Test
    public void test_mapper_conversion_between_entity_and_dto() {
        // Arrange
        AccountEntity accountEntity = AccountEntity.builder()
            .accountId(1L)
            .firstName("John")
            .lastName("Doe")
            .email("john.doe@example.com")
            .phone("0123456789")
            .identification("123456789012")
            .build();
    
        Account accountDto = Account.builder()
            .accountId(1L)
            .firstName("John")
            .lastName("Doe")
            .email("john.doe@example.com")
            .phone("0123456789")
            .identification("123456789012")
            .build();
    
        when(mapper.toDto(accountEntity)).thenReturn(accountDto);
        when(mapper.toEntity(accountDto)).thenReturn(accountEntity);
    
        // Act
        Account resultDto = mapper.toDto(accountEntity);
        AccountEntity resultEntity = mapper.toEntity(accountDto);
    
        // Assert
        assertNotNull(resultDto);
        assertNotNull(resultEntity);
        assertEquals(accountDto, resultDto);
        assertEquals(accountEntity, resultEntity);
        verify(mapper).toDto(accountEntity);
        verify(mapper).toEntity(accountDto);
    }

    // Test that update operation only updates fields that have changed
    @Test
    public void test_update_only_changes_modified_fields() {
        // Arrange
        Long accountId = 1L;
        Account existingAccount = Account.builder()
            .accountId(accountId)
            .email("old.email@example.com")
            .phone("0123456789")
            .identification("123456789012")
            .build();
    
        Account updatedAccount = Account.builder()
            .accountId(accountId)
            .email("new.email@example.com")
            .phone("0123456789")
            .identification("123456789012")
            .build();
    
        AccountEntity foundAccountEntity = new AccountEntity();
        foundAccountEntity.setEmail("old.email@example.com");
        foundAccountEntity.setPhone("0123456789");
        foundAccountEntity.setIdentification("123456789012");
    
        AccountEntity updatedAccountEntity = new AccountEntity();
        updatedAccountEntity.setEmail("new.email@example.com");
        updatedAccountEntity.setPhone("0123456789");
        updatedAccountEntity.setIdentification("123456789012");
    
        AuditableEntity auditableEntity = new AuditableEntity();
    
        when(repository.findById(accountId)).thenReturn(Optional.of(foundAccountEntity));
        when(auditableUseCase.createAuditableForUpdate()).thenReturn(auditableEntity);
        when(repository.save(any(AccountEntity.class))).thenReturn(updatedAccountEntity);
        when(mapper.toDto(any(AccountEntity.class))).thenReturn(updatedAccount);
    
        // Act
        Account result = accountCommandService.update(accountId, updatedAccount);
    
        // Assert
        assertNotNull(result);
        assertEquals("new.email@example.com", result.email());
        verify(repository).findById(accountId);
        verify(repository).existsByEmail("new.email@example.com");
        verify(mapper).update(foundAccountEntity, updatedAccount);
        verify(auditableUseCase).createAuditableForUpdate();
        verify(repository).save(foundAccountEntity);
        verify(mapper).toDto(updatedAccountEntity);
    }
}